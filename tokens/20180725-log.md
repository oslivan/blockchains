## 记录一次验证合约的辛酸史

+ 背景
去年刚加入一家区块链创业公司，于是开始接触区块链应用，起先因为不懂，通过Mist为公司的客户发行了一些Token。导致现在无法验证合约源码，原因在于通过Mist发布的合约，无法获知编译Contract的solc版本号，所以有了下面的劳动成果。

+ 第一步
在etherscan上面找到了该Token的信息，将Bytecode提取出来，放置于一个文件中。

+ 第二步
打开当时发布Token的Mist程序，然后查看到版本号为0.9.0，然后去到Github下载该版本的源码，查看package.json文件，里面显示依赖的solc（用于编译Contract）版本大于0.4.11，接着又查看了该版本发布的时间，通过这两项大概确定了solc版本在0.4.11~0.4.13之间，这样就已经排除了大部分solc编译版本。

+ 第三步
进入 http://remix.ethereum.org 网站，将合约的代码拷贝进来，然后每个版本都尝试编译一下（大约有60多个版本需要尝试），对于每一次的编译结果要跟第一步保存的ByteCode进行匹配，然后查看其匹配程度，幸运的是只尝试了几次，就让我发现了一个相似度极高的编译版本，然后以他为中心向两边依次尝试，通过这种尝试将可能的结果从60多个变成了7个，虽然这七个没有一个完全匹配，总是有68个字符不一样，但已经足以进行验证了。、

+ 第四步
进入 etherscan 的合约验证页面，然后填写基本信息，构造ABI的参数，然后选依次用这七个版本进行验证。结果使用0.4.13-commit版本编译成功。


## 如何构造第四步中的ABI参数
```
#假设构造函数的参数如下
var initialSupply = 10000000000000;
var tokenName     = "Hello World";
var decimalUnits  = 4
var tokenSymbol   = "HWC";

1. 将 10000000000000 转化为32字节的16进制的数字
000000000000000000000000000000000000000000000000000009184E72A000
2. 对于 "Hello World" 的处理比较特殊，它的内容会在其他参数排完之后，再进行设置，当前只需设置他的开始位置即可。
0000000000000000000000000000000000000000000000000000000000000080
3. 将 4 也转化为 16进制数字
0000000000000000000000000000000000000000000000000000000000000004
4. 同 2 
00000000000000000000000000000000000000000000000000000000000000C0
5. 现在所有参数都排完了，准备设置前面的字符串内容（长度+内容，将字符串转为ASCII的16进制），首先是第二个参数 "Hello World"
000000000000000000000000000000000000000000000000000000000000000B
48656C6C6F20576F726C64000000000000000000000000000000000000000000
6. 接着设置 第四个参数 "HWC"
0000000000000000000000000000000000000000000000000000000000000003
4857430000000000000000000000000000000000000000000000000000000000

# 现在每一项参数都设置好了，只需要将他们按1-6的顺序组合就行。
```
